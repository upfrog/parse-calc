
function main() {
    let tokens = []
    
    //test
    //tokens = tokenizeInput("34 + 555 * (2.699998 - 8) + 2 / 4");
    //tokens = tokenizeInput("44+82");

    //tokens = tokenizeInput("3+(44*(5+6)/2)-1");

    //tokens = tokenizeInput("5+3+6")

    tokens = tokenizeInput("3^(5+2/1)");
    tokens = tokenizeInput("2^3^4^5");
    tokens = tokenizeInput("3*(5+8/6)^3^4^(4*7)");
    

    let p = new Parser(tokens);
    console.log(p);
    let root = p.generateParseTree(tokens);

    console.log(root);
    console.log(root.r);
}


/**
 * 
 * Should I have a separate tokenization step, or should I parse the raw input?
 * 
 * I think I should separate them. The downside is that tokenization may be of limited use. It will
 *  be important for numbers, where many digits may only relate to a single number data type, but 
 * it may be less important for other forms of input, which will mean that in many cases the 
 * tokenization brings no benefit.
 * 
 * However, it will also give me a seperate place for input validation, and it will help cover me
 * for the future. I haven't decided exactly what operations to support, but in the long run, 
 * separating tokenization into it's own function, and having the parse function focus on, well,
 * parsing will probably make the code more expandable.
 * 
 * 
 * 
 * What do I need to tokenize and combine?
 *  -numbers (multi-digit, negative)
 *  -numbers (imaginary?)
 *  -numbers (e)??
 *  -exponents
 * 
 * 
 * 
 * 
 * @param {*} input 
 * @param {*} tokens 
 * @param {*} input_i 
 * @param {*} tokens_i 
 */
function tokenizeInput(input) {

    let inArr = [...input];
    let tokens = [];

    let i = 0;

    while (i < inArr.length) {
        if (inArr[i] == " ") {
            ++i;
        }
        else if (inArr[i] == "(" || inArr[i] == ")") {
            tokens.push(inArr[i]);
            ++i;
        }
        else if (!isNaN((inArr[i]))) {
            let end = getNumEnd(inArr, i);
            tokens.push(inArr.slice(i, end).join(""))
            i = end;
        }
        else if (isSingleCharOpp(inArr[i])) {
            tokens.push(inArr[i]);
            ++i;
        }
    }
    return tokens;
}

function getNumEnd(input, i) {
    while (i < input.length && (!isNaN(parseInt(input[i]))) || input[i] == "." ) {
        ++i;
    }
    return i;
}

function isSingleCharOpp(elem) {
    const singleCharOpps = ["+","-","*","^","/"];
    return singleCharOpps.includes(elem);
}

class Parser {
    constructor(tokens) {
        this.tokens = tokens;
        this.curPos = 0;
        this.curToken = this.tokens != null ? this.tokens[this.curPos] : null;
    }

    advanceToken() {
        this.curPos++;
        if (this.curPos < this.tokens.length) {
            this.curToken = this.tokens[this.curPos];
        }
        else {
            this.curToken = null;
        }
        
    }
    
    generateParseTree() {

        let node = this.parseAddSub();
        return node;
    }
    
    /**
     * This is more to help me get this clear in my head.
     * 
     * These functions work by pushing precedence down.
     * 
     * What do I mean by that? This builds a tree, which will later be evaluated.
     * It will generally be evaluated by combining a root node, and it's two branches. In
     * order to evaluate such an expression, both of the child nodes must be constants. If
     * they are instead operators, then we need to traverse that side of the tree until we
     * can turn it into a constant. This means that operations which are buried deeper in
     * the tree are evaluated first; earlier nodes may be traversed over, but the operation
     * they serve as input to cannot be evaluated yet.
     *  
     * This is why each function first tries to parse the next-highest level of precedence.
     * The expression is entered with parseAddSub(), which will keep on looping until there
     * is a non + - operation, or until the expression is over. If there is a non + - 
     * operation, then the next level of precedence is called, and that will continue until
     * the appropriate level is found. That level will then loop if needed, and then ascend
     * to a higher level.
     * 
     * Key to this is that each function can 1) repeat it's own operation indefinitely, 2)
     * go to a higher level of precedence, and 3) be returned to by a lower level of
     * precedence.
     * 
     * The right node is always generated by parsing the next layer of precedence up, and
     * that parsing has to complete before the current level can be finished. If, in the
     * process of parsing to generate a right node, the program finds something of lower
     * precedence, it will not parse it. Instead it will return up the call stack (which
     * is down the chain of precedence) until it reaches the appropriate function.
     * 
     * 
     */


    /*
    TODO:
    - Clean up parse functions a bit
    - Build in-order traversal
    - Make that traversal evaluate the tree
    - Build some test cases with the current tree structure
    - Fix any bugs
    - Build starter GUI
    - Deploy
    - More rigorous input validation
    - Add new features!
        - Record history
        - New operators.
            - Sqrt
                - May need a custom way to display it - "sqrt()" is a bit lame.
            - Factorial
            - Natural log
            - e?
            - Trig functions
                - Keep an eye on degrees vs radians
            - Absolute Value
            - Some of these may be best handled by creating a new node type for unary 
              operators.
                - For that matter, consider making a dedicated terminal node type
        - Make sure you can handle floating point math reasonably
        - RPN mode
            - Will be best served with a new, stack-based backend, which should be
              much easier to implement
            - Add highlighting to show which terms on the stack a given operation
              will effect!
    
        

    */

    parseAddSub() {
        let node = this.parseMultDiv();

        while (this.curToken == "+" || this.curToken == "-") {
            let operation = this.curToken;
            this.advanceToken();
            let rightNode = this.parseMultDiv();
            node = new Node(operation, node, rightNode);
        }
        return node;
    }

    parseMultDiv() {
        let node = this.parseExp();

        while (this.curToken == "*" || this.curToken == "/") {
            let operation = this.curToken;
            this.advanceToken();
            let rightNode = this.parseExp();
            node = new Node(operation, node, rightNode);
        }
        return node;
    }

    parseExp() {
        let node = this.parseTerm();

        while (this.curToken == "^") {
            let operation = this.curToken;
            this.advanceToken();
            let rightNode = this.parseTerm();
            node = new Node(operation, node, rightNode);
        }
        return node;
    }

    parseTerm() {
        if (this.curToken == "(") {
            this.advanceToken();
            let node = this.generateParseTree();
            if (this.curToken == ")") {
                this.advanceToken();
            } 
            else {
                throw new Error("Mismatched parentheses.");
            }
            return node;
        } 
        else if (!(isNaN(parseInt(this.curToken)))) {
            let node = new Node();
            node.val = this.curToken;
            this.advanceToken();
            return node;
        }

    }
}

class Node {
    constructor(val = null, l = null, r = null) {
        this.val = val;
        this.l = l;
        this.r = r;

        return this;
    }
}

main();